import time
import random
from multiprocessing import Process, Pipe
import argparse
import sys
import os
import tqdm
from datetime import datetime
import colorama
from colorama import Fore, Style


# Importiere das Modul argparse, um Befehlszeilenargumente zu parsen
import argparse

# Erstelle einen ArgumentParser-Objekt mit einer Beschreibung des Programms
parser = argparse.ArgumentParser(description='Buzzword Bingo Spiel.')

# FÃ¼ge ein Argument hinzu, um die Anzahl der Felder in der Breite zu spezifizieren
parser.add_argument('-xaxis', type=int, required=True, help='Anzahl der Felder in der Breite')

# FÃ¼ge ein Argument hinzu, um die Anzahl der Felder in der HÃ¶he zu spezifizieren
parser.add_argument('-yaxis', type=int, required=True, help='Anzahl der Felder in der HÃ¶he')

# FÃ¼ge ein Argument hinzu, um den Pfad zur Textdatei mit den WÃ¶rtern zu spezifizieren
parser.add_argument('-wordfile', type=str, required=True, help='Pfad zur Textdatei mit den WÃ¶rtern')

# Parse die Argumente, die Ã¼ber die Befehlszeile Ã¼bergeben wurden
args = parser.parse_args()

# Nun kÃ¶nnen die Argumente args.xaxis, args.yaxis und args.wordfile im Programm verwendet werden


LOG_DIR = "logs" # Verzeichnis, in dem die Log-Dateien gespeichert werden

def read_words_from_file(filepath):
    """Liest WÃ¶rter aus einer Datei und gibt sie als Liste zurÃ¼ck."""
    try:
        # Ã–ffne die Datei im Lesemodus mit UTF-8-Kodierung
        with open(filepath, 'r', encoding='utf-8') as file:
            # Lies jede Zeile der Datei, entferne fÃ¼hrende und nachgestellte Leerzeichen
            # und fÃ¼ge sie der Liste hinzu, wenn sie nicht leer ist
            words = [line.strip() for line in file if line.strip()]
        return words  # Gib die Liste der WÃ¶rter zurÃ¼ck
    except FileNotFoundError:
        # Behandle den Fall, dass die Datei nicht gefunden wurde
        print(f"Error: File {filepath} not found.")
        sys.exit(1)  # Beende das Programm mit einem Fehlerstatus
    except Exception as e:
        # Behandle alle anderen Ausnahmen, die beim Lesen der Datei auftreten kÃ¶nnen
        print(f"Error reading file {filepath}: {e}")
        sys.exit(1)  # Beende das Programm mit einem Fehlerstatus

def welcome_screen():
    """Zeigt einen stilvollen BegrÃ¼ÃŸungsbildschirm an."""
    print(Fore.YELLOW + r"""
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— 
â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ–ˆâ•”â•â•šâ•â•â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ–ˆâ•”â•  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•
â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•šâ•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•     â•šâ•â•â•â•â•â• â•šâ•â•â•šâ•â•  â•šâ•â•â•â• â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• 
                                                                                                               
                                                                                                                                                


""" + Style.RESET_ALL)
    print(Fore.YELLOW + r"""

â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—     â–ˆâ–ˆâ•—     â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—                            
â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘                            
â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘                            
â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•šâ•â•                            
â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•—                            
 â•šâ•â•â•â•šâ•â•â• â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•     â•šâ•â•â•šâ•â•     â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•â•â•šâ•â•                            
                                                                                                                     
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—         â–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—         
â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•    â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘         â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•         
â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘         â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘            
â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘    â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘         â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘            
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—
â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•    â•šâ•â•â•â•â•â•â•â•šâ•â•     â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•    â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•    â•šâ•â•   â•šâ•â•â•šâ•â•â•šâ•â•
                                                                                                                     

 """+ Style.RESET_ALL)
    time.sleep(2)


def loading_animation(duration=5):
    """Zeigt eine Ladeanimation an."""
    for _ in tqdm.tqdm(range(101), ncols=100, unit="ğŸ”³", ascii=False,
                       bar_format="{desc}: {bar} {percentage:3.0f}%",
                       colour='green'):
             time.sleep(duration / 200)


def create_bingo_card(words, width, height):
    """Erstellt eine Bingokarte mit den angegebenen WÃ¶rtern, der Breite und der HÃ¶he."""
    random.shuffle(words)
    card = [words[i * width:(i + 1) * width] for i in range(height)]
    if width == height and width in [5, 7]:
        middle_index = width // 2
        card[height // 2][middle_index] = "X"  # Ensure middle cell is marked
    return card


def print_bingo_card(card):
    """Druckt die Bingokarte in Tabellenformat und ersetzt markierte WÃ¶rter durch 'X'."""
    max_word_length = max(len(word) for row in card for word in row)
    for row in card:
        line = "+".join(["-" * (max_word_length + 2)] * len(row))
        print(f"+{line}+")
        for word in row:
            display_word = "X" if word == "X" else word
            print(f"| {display_word.center(max_word_length)} ", end="")
        print("|")
    line = "+".join(["-" * (max_word_length + 2)] * len(card[0]))
    print(f"+{line}+")


def check_win(card):
   """ÃœberprÃ¼ft, ob es eine Gewinnbedingung auf der Bingokarte gibt."""
    # ÃœberprÃ¼ft die Reihen auf eine Gewinnbedingung
    for row in card:
        if all(cell == "X" for cell in row):
            return True
    # ÃœberprÃ¼ft die Spalten auf eine Gewinnbedingung
    for col in range(len(card[0])):
        if all(row[col] == "X" for row in card):
            return True
    # ÃœberprÃ¼ft die erste Diagonale (oben links nach unten rechts) auf eine Gewinnbedingung
    if all(card[i][i] == "X" for i in range(len(card))):
        return True
    # ÃœberprÃ¼ft die zweite Diagonale (oben rechts nach unten links) auf eine Gewinnbedingung
    if all(card[i][len(card) - 1 - i] == "X" for i in range(len(card))):
        return True
    return False


def player_process(pipe, player_num, width, height, words):
    """Prozess fÃ¼r jeden Spieler, um ihre Bingokarte und Aktionen zu verwalten."""
    # EmpfÃ¤ngt den Spielernamen vom Hauptprozess Ã¼ber die Pipe (Alter wird ignoriert)
    name, _ = pipe.recv()  # Receive player name, ignore age

    # Erstellt eine Bingokarte fÃ¼r den Spieler mit den bereitgestellten WÃ¶rtern, Breite und HÃ¶he
    bingo_card = create_bingo_card(words, width, height)

    # Sendet die erstellte Bingokarte zurÃ¼ck an den Hauptprozess
    pipe.send(bingo_card)

    while True:
        # EmpfÃ¤ngt ein Wort vom Hauptprozess
        word = pipe.recv()
        # EmpfÃ¤ngt die Antwort des Spielers, ob das Wort markiert werden soll
        response = pipe.recv()

        if response.lower() == 'j': # Wenn die Antwort 'j' ist, markiere das Wort auf der Karte
            marked = False
            mark_row = -1
            mark_col = -1

            # Findet und markiert das Wort auf der Bingokarte
            for i in range(height):
                for j in range(width):
                    if bingo_card[i][j] == word:
                        bingo_card[i][j] = "X"
                        marked = True
                        mark_row = i
                        mark_col = j
                        break
                if marked:
                    break

            # Sendet die Spielernummer, das Wort, den Gewinnstatus und die Position des markierten Wortes zurÃ¼ck
            pipe.send((player_num, word, check_win(bingo_card), mark_row, mark_col))
        else:
            # Wenn die Antwort nicht 'j' ist, sende None
            pipe.send(None)

        # Sendet die aktualisierte Bingokarte zurÃ¼ck an den Hauptprozess
        pipe.send(bingo_card)

        # Fragt, ob der Spieler seine Entscheidung rÃ¼ckgÃ¤ngig machen mÃ¶chte
        undo_response = pipe.recv()
        if undo_response.lower() == 'j' and response.lower() == 'j':
            # Hebt die Markierung auf, wenn der Spieler sich entscheidet, rÃ¼ckgÃ¤ngig zu machen
            bingo_card[mark_row][mark_col] = word

        # Protokolliert die aktuelle Aktion mit einem Zeitstempel
        timestamp = datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
        log_message = f"{timestamp} Wort {word} markiert"
        write_to_log(player_num, log_message)

# Schreibt eine Nachricht in die Log-Datei fÃ¼r einen bestimmten Spieler
def write_to_log(player_num, message):
    """Schreibt eine Nachricht in die Log-Datei fÃ¼r einen bestimmten Spieler."""
    # Holt den aktuellen Zeitstempel im angegebenen Format
    timestamp = datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
    # Erstellt den Dateinamen basierend auf der Spielernummer
    filename = os.path.join(LOG_DIR, f"bingo-Spieler{player_num}.txt")
    # Ã–ffnet die Log-Datei im Anhangmodus und schreibt die Nachricht mit einem Zeilenumbruch
    with open(filename, 'a') as log_file:
        log_file.write(message + "\n")

# Speichert alle Spieler-Logs in einer einzelnen Datei
def save_logs_to_file():
    """Speichert alle Spieler auf eine einzige Datei."""
    # Listet alle Dateien im Log-Verzeichnis auf, die dem Muster 'bingo-Spieler*.txt' entsprechen
    log_files = [f for f in os.listdir(LOG_DIR) if f.endswith('.txt') and f.startswith('bingo-Spieler')]
    # Wenn keine Log-Dateien gefunden werden, gibt eine Nachricht aus und beendet die Funktion
    if not log_files:
        print("Keine Log-Dateien gefunden.")
        return

    # Ã–ffnet die Ausgabedatei im Schreibmodus
    with open(os.path.join(LOG_DIR, 'Log-Datei.txt'), 'w') as output_file:
        # Schreibt den Header fÃ¼r die zusammengefÃ¼hrte Log-Datei
        output_file.write("ZusammengefÃ¼hrte Log-Datei\n")
        output_file.write("=" * 50 + "\n\n")

        # Iteriert Ã¼ber jede Log-Datei
        for log_file in log_files:
            # Schreibt den Log-Dateinamen als AbschnittsÃ¼berschrift in die zusammengefÃ¼hrte Log-Datei
            output_file.write(f"Log-Datei: {log_file}\n")
            output_file.write("=" * 50 + "\n")
            # Ã–ffnet jede einzelne Log-Datei im Lesemodus
            with open(os.path.join(LOG_DIR, log_file), 'r') as input_file:
                # Schreibt den Inhalt der einzelnen Log-Datei in die zusammengefÃ¼hrte Log-Datei
                output_file.write(input_file.read())
            # FÃ¼gt etwas Platz zwischen den Log-Datei-Inhalten in der zusammengefÃ¼hrten Log-Datei hinzu
            output_file.write("\n\n")

def main():
    # ÃœberprÃ¼fen, ob das Verzeichnis fÃ¼r Logs existiert, und gegebenenfalls erstellen
    if not os.path.exists(LOG_DIR):
        os.makedirs(LOG_DIR)

    # BegrÃ¼ÃŸungsbildschirm und Ladeanimation anzeigen
    welcome_screen()
    loading_animation()
    print("\nDas Spiel ist fertig geladen! Um das Spiel zu starten:")

    # WÃ¶rter aus der angegebenen Datei lesen
    words_from_file = read_words_from_file(args.wordfile)
    # ÃœberprÃ¼fen, ob genÃ¼gend WÃ¶rter fÃ¼r die Bingokarten vorhanden sind
    if len(words_from_file) < args.xaxis * args.yaxis:
        print(f"{Fore.RED}Fehler: Nicht genug WÃ¶rter in der Datei.{Style.RESET_ALL}")
        sys.exit(1)

    # Anzahl der Spieler abfragen
    num_players = int(input("Geben Sie die Anzahl der Spieler ein? "))

    # Mindestens zwei Spieler werden benÃ¶tigt
    if num_players < 2:
        print(f"{Fore.RED}Mindestens zwei Spieler werden benÃ¶tigt.{Style.RESET_ALL}")
        sys.exit(1)

    parent_conns = []
    child_conns = []
    players = []

    # Spielerinformationen sammeln und Verbindungen fÃ¼r die Interprozesskommunikation erstellen
    for i in range(num_players):
        parent_conn, child_conn = Pipe()
        parent_conns.append(parent_conn)
        child_conns.append(child_conn)

        player_name = input(f"Geben Sie den Namen des Spielers {i + 1} ein: ")
        players.append((player_name, None))  # Alter wird nicht abgefragt

    processes = []
    cards = []

    # Prozesse fÃ¼r die Spieler starten und Bingokarten erstellen
    for i in range(num_players):
        p = Process(target=player_process, args=(child_conns[i], i + 1, args.xaxis, args.yaxis, words_from_file))
        processes.append(p)
        p.start()

        parent_conns[i].send(players[i])
        card = parent_conns[i].recv()
        cards.append(card)

        print(f"\n{Fore.YELLOW}Spieler {i + 1} ({players[i][0]}) Bingokarte:{Style.RESET_ALL}")
        print_bingo_card(card)

    # WÃ¶rter zufÃ¤llig mischen
    random.shuffle(words_from_file)
    for word in words_from_file:
        responses = []
        for i in range(num_players):
            parent_conns[i].send(word)

            # Abfrage, ob der Spieler das Wort auf seiner Karte hat
            while True:
                response = input(f"{Fore.CYAN}Spieler {i + 1}, hast du das Wort '{word}'? (j/n) {Style.RESET_ALL}")
                if response.lower() in ['j', 'n']:
                    break
                else:
                    print(f"{Fore.RED}Bitte geben Sie 'j' fÃ¼r Ja oder 'n' fÃ¼r Nein ein.{Style.RESET_ALL}")

            parent_conns[i].send(response)
            responses.append((i, response))

        winners = []
        for i, response in responses:
            result = parent_conns[i].recv()
            if isinstance(result, tuple) and len(result) >= 3:
                player_num, word, win, mark_row, mark_col = result[:5]
                if win:
                    winners.append(player_num)
                    write_to_log(player_num, f"{datetime.now().strftime('%Y-%m-%d-%H-%M-%S')} Sieg")

        if winners:
            for winner in winners:
                print(f"\n{Fore.GREEN}Spieler {winner} ({players[winner - 1][0]}) hat gewonnen!{Style.RESET_ALL}")
                parent_conns[winner - 1].send(None)
                if parent_conns[winner - 1].poll():
                    winner_card = parent_conns[winner - 1].recv()
                    print(f"\n{Fore.GREEN}Aktualisierte Gewinnerkarte fÃ¼r Spieler {winner} ({players[winner - 1][0]}):{Style.RESET_ALL}")
                    print_bingo_card(winner_card)
                else:
                    print(f"Die Verbindung zu Spieler {winner} wurde geschlossen. Kann keine Gewinnerkarte empfangen.")

                write_to_log(winner, f"{datetime.now().strftime('%Y-%m-%d-%H-%M-%S')} Ende des Spiels")

            # Alle Prozesse beenden und Logs speichern
            for p in processes:
                p.terminate()
            save_logs_to_file()
            colorama.deinit()  # Terminalfarben zurÃ¼cksetzen
            sys.exit(0)

        for i, response in responses:
            updated_card = parent_conns[i].recv()
            cards[i] = updated_card
            print(f"\n{Fore.YELLOW}Aktualisierte Bingokarte fÃ¼r Spieler {i + 1} ({players[i][0]}):{Style.RESET_ALL}")
            print_bingo_card(updated_card)

    # Warten auf das Ende aller Prozesse
    for p in processes:
        p.join()

    # Logs speichern und Abschlussmeldung
    save_logs_to_file()
    print(f"{Fore.YELLOW}Log-Dateien wurden erfolgreich in 'Log-Datei.txt' gespeichert.{Style.RESET_ALL}")
    colorama.deinit()  # Terminalfarben zurÃ¼cksetzen

if __name__ == "__main__":
    main()
