import sys
import time
import random
from multiprocessing import Process, Pipe
import argparse
import tqdm
from datetime import datetime
import os
import colorama
from colorama import Fore, Style

# Argument parsing
parser = argparse.ArgumentParser(description='Buzzword Bingo Spiel.')
parser.add_argument('-xaxis', type=int, required=True, help='Anzahl der Felder in der Breite')
parser.add_argument('-yaxis', type=int, required=True, help='Anzahl der Felder in der Höhe')
parser.add_argument('-wordfile', type=str, required=True, help='Pfad zur Textdatei mit den Wörtern')
args = parser.parse_args()

LOG_DIR = "logs"


def read_words_from_file(filepath):
    """Read words from a file and return them as a list."""
    try:
        with open(filepath, 'r', encoding='utf-8') as file:
            words = [line.strip() for line in file if line.strip()]
        return words
    except FileNotFoundError:
        print(f"Error: File {filepath} not found.")
        sys.exit(1)
    except Exception as e:
        print(f"Error reading file {filepath}: {e}")
        sys.exit(1)


def welcome_screen():
   #Zeigt einen stilvollen Begrüßungsbildschirm mit ASCII-Kunst in gelber Farbe an und wartet 2 Sekunden, bevor das Programm fortgesetzt wird.
    print(Fore.YELLOW + r"""
██████╗ ██╗   ██╗███████╗███████╗██╗    ██╗ ██████╗ ██████╗ ██████╗     ██████╗ ██╗███╗   ██╗ ██████╗  ██████╗ 
██╔══██╗██║   ██║╚══███╔╝╚══███╔╝██║    ██║██╔═══██╗██╔══██╗██╔══██╗    ██╔══██╗██║████╗  ██║██╔════╝ ██╔═══██╗
██████╔╝██║   ██║  ███╔╝   ███╔╝ ██║ █╗ ██║██║   ██║██████╔╝██║  ██║    ██████╔╝██║██╔██╗ ██║██║  ███╗██║   ██║
██╔══██╗██║   ██║ ███╔╝   ███╔╝  ██║███╗██║██║   ██║██╔══██╗██║  ██║    ██╔══██╗██║██║╚██╗██║██║   ██║██║   ██║
██████╔╝╚██████╔╝███████╗███████╗╚███╔███╔╝╚██████╔╝██║  ██║██████╔╝    ██████╔╝██║██║ ╚████║╚██████╔╝╚██████╔╝
╚═════╝  ╚═════╝ ╚══════╝╚══════╝ ╚══╝╚══╝  ╚═════╝ ╚═╝  ╚═╝╚═════╝     ╚═════╝ ╚═╝╚═╝  ╚═══╝ ╚═════╝  ╚═════╝ 
                                                                                                               
                                                                                                                                                


""" + Style.RESET_ALL)
    print(Fore.YELLOW + r"""

██╗    ██╗██╗██╗     ██╗     ██╗  ██╗ ██████╗ ███╗   ███╗███╗   ███╗███████╗███╗   ██╗██╗                            
██║    ██║██║██║     ██║     ██║ ██╔╝██╔═══██╗████╗ ████║████╗ ████║██╔════╝████╗  ██║██║                            
██║ █╗ ██║██║██║     ██║     █████╔╝ ██║   ██║██╔████╔██║██╔████╔██║█████╗  ██╔██╗ ██║██║                            
██║███╗██║██║██║     ██║     ██╔═██╗ ██║   ██║██║╚██╔╝██║██║╚██╔╝██║██╔══╝  ██║╚██╗██║╚═╝                            
╚███╔███╔╝██║███████╗███████╗██║  ██╗╚██████╔╝██║ ╚═╝ ██║██║ ╚═╝ ██║███████╗██║ ╚████║██╗                            
 ╚══╝╚══╝ ╚═╝╚══════╝╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═╝     ╚═╝╚═╝     ╚═╝╚══════╝╚═╝  ╚═══╝╚═╝                            
                                                                                                                     
██████╗  █████╗ ███████╗    ███████╗██████╗ ██╗███████╗██╗         ██╗      █████╗ ███████╗██████╗ ████████╗         
██╔══██╗██╔══██╗██╔════╝    ██╔════╝██╔══██╗██║██╔════╝██║         ██║     ██╔══██╗██╔════╝██╔══██╗╚══██╔══╝         
██║  ██║███████║███████╗    ███████╗██████╔╝██║█████╗  ██║         ██║     ███████║█████╗  ██║  ██║   ██║            
██║  ██║██╔══██║╚════██║    ╚════██║██╔═══╝ ██║██╔══╝  ██║         ██║     ██╔══██║██╔══╝  ██║  ██║   ██║            
██████╔╝██║  ██║███████║    ███████║██║     ██║███████╗███████╗    ███████╗██║  ██║███████╗██████╔╝   ██║   ██╗██╗██╗
╚═════╝ ╚═╝  ╚═╝╚══════╝    ╚══════╝╚═╝     ╚═╝╚══════╝╚══════╝    ╚══════╝╚═╝  ╚═╝╚══════╝╚═════╝    ╚═╝   ╚═╝╚═╝╚═╝
                                                                                                                     

 """+ Style.RESET_ALL)
    time.sleep(2)


def loading_animation(duration=5):
    #Zeigt eine Ladeanimation mit einem Fortschrittsbalken an, der schrittweise über die angegebene Dauer von 0% auf 100% ansteigt.
    for _ in tqdm.tqdm(range(101), ncols=100, unit="🔳", ascii=False,
                       bar_format="{desc}: {bar} {percentage:3.0f}%",
                       colour='green'):
        time.sleep(duration / 200)

def create_bingo_card(words, width, height):
#Erstellt eine Bingo-Karte mit den gegebenen Wörtern, der Breite und der Höhe und markiert das mittlere Feld mit "X" bei quadratischen Karten (5x5 oder 7x7).
    random.shuffle(words)
    card = [[words[row * width + col] for col in range(width)] for row in range(height)]
    if width == height and width in [5, 7]:
        middle_index = width // 2
        card[height // 2][middle_index] = "X"  # Ensure middle cell is marked
    return card


def print_bingo_card(card):
    #Gibt die Bingo-Karte im Tabellenformat aus, wobei 'X' für markierte Wörter verwendet wird.
    max_word_length = max(len(word) for row in card for word in row)
    for i, row in enumerate(card):
        line = "+".join(["-" * (max_word_length + 2)] * len(row))
        print(f"+{line}+")
        for j, word in enumerate(row):
            display_word = "X" if word == "X" else word
              if j == 0:  # Print player name in the first column
                print(f"| {row[0].center(max_word_length)}{Style.RESET_ALL} ", end="")
            else:
                print(f"| {display_word.center(max_word_length)} ", end="")
        print("|")
    line = "+".join(["-" * (max_word_length + 2)] * len(card[0]))
    print(f"+{line}+")


def check_win(card):
    """Check if there is a win condition in the bingo card."""
    winners = []

    # Check rows
    for i, row in enumerate(card):
        if all(cell == "X" for cell in row):
            winners.append(i + 1)  # Player number is index + 1

    # Check columns
    for col in range(len(card[0])):
        if all(row[col] == "X" for row in card):
            winners.append(col + 1)  # Player number is index + 1

    # Check diagonals
    if all(card[i][i] == "X" for i in range(len(card))):
        winners.append("diagonal1")  # Diagonal 1 win
    if all(card[i][len(card) - 1 - i] == "X" for i in range(len(card))):
        winners.append("diagonal2")  # Diagonal 2 win

    return winners



def toggle_button(card, row, col):
    """Toggle the state of a cell in the bingo card."""
    card[row][col] = "X" if card[row][col] == " " else "X"


def player_process(pipe, player_num, width, height, words):
    """Process for each player to handle their bingo card and actions."""
    try:
        name, _ = pipe.recv()  # Receive player name, ignore age
        write_to_log(player_num, f"Spieler {player_num} - Start des Spiels")

        bingo_card = create_bingo_card(words, width, height)
        pipe.send(bingo_card)

        while True:
            message = pipe.recv()
            if message == 'quit':
                write_to_log(player_num, f"Spieler {player_num} - Ende des Spiels")
                break
            elif message.startswith('toggle'):
                _, col, row = message.split()
                row, col = int(row), int(col)
                if 0 <= row < height and 0 <= col < width:
                    toggle_button(bingo_card, row, col)
                    write_to_log(player_num, f"{words[row * width + col]} ({col + 1}/{row + 1}) markiert")
                    pipe.send(bingo_card)
                else:
                    write_to_log(player_num, f"Spieler {player_num} - Ungültige Koordinaten.")
                    print("Ungültige Koordinaten. Bitte geben Sie erneut ein.")
            elif message == 'get_card':
                pipe.send(bingo_card)
            elif message == 'undo':
                for r in range(height):
                    for c in range(width):
                        if bingo_card[r][c] == "X":
                            bingo_card[r][c] = words[r * width + c]
                pipe.send(bingo_card)
            elif message.startswith('undo '):
                _, col, row = message.split()
                row, col = int(row), int(col)
                if 0 <= row < height and 0 <= col < width:
                    if bingo_card[row][col] == "X":
                        bingo_card[row][col] = words[row * width + col]
                        pipe.send(bingo_card)
                        write_to_log(player_num, f"{words[row * width + col]} ({col + 1}/{row + 1}) rückgängig gemacht")
                    else:
                        bingo_card[row][col] = "X"
                        pipe.send(bingo_card)
                        write_to_log(player_num, f"{words[row * width + col]} ({col + 1}/{row + 1}) markiert")
                else:
                    write_to_log(player_num, f"Spieler {player_num} - Ungültige Koordinaten.")
                    print("Ungültige Koordinaten. Bitte geben Sie erneut ein.")
    except Exception as e:
        write_to_log(player_num, f"Spieler {player_num} - Fehler: {str(e)}")
        print(f"Fehler in Spieler {player_num}: {e}")
    finally:
        write_to_log(player_num, f"Spieler {player_num} - Spiel beendet")


def write_to_log(player_num, message):
    """Write a message to the log file for a specific player."""
    timestamp = datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
    filename = os.path.join(LOG_DIR, f"{timestamp}-bingo-Spieler{player_num}.txt")
    with open(filename, 'a') as log_file:
        log_file.write(f"{timestamp}:message + "\n")


def save_logs_to_file():
    """Save all player logs to a single file."""
    log_files = [f for f in os.listdir(LOG_DIR) if f.endswith('.txt') and f.startswith('bingo-Spieler')]

    if not log_files:
        print("Keine Log-Dateien gefunden.")
        return

    with open(os.path.join(LOG_DIR, 'Log-Datei.txt'), 'w') as output_file:
        output_file.write("Zusammengeführte Log-Datei\n")
        output_file.write("=" * 50 + "\n\n")

        for log_file in log_files:
            output_file.write(f"Log-Datei: {log_file}\n")
            output_file.write("=" * 50 + "\n")
            with open(os.path.join(LOG_DIR, log_file), 'r') as input_file:
                output_file.write(input_file.read())
            output_file.write("\n\n")

def play_game(parent_conns, processes, cards, players, width, height):
    player_names = [player[0] for player in players]

    while True:
        # Collect player choices
        player_choices = []
        for i in range(len(players)):
            current_player_name = player_names[i]
            current_player_index = i

            try:
                print(f"\n{Fore.YELLOW}Spieler {current_player_name} ist an der Reihe.{Style.RESET_ALL}")

                while True:
                    choice = input(f"\nGeben Sie Koordinaten (z.B. '1 1') ein oder 's' zum Überspringen oder 'r' zum Verbessern oder 'q' zum Beenden: {Style.RESET_ALL}")

                    if choice.lower() == 'q':
                        for conn in parent_conns:
                            conn.send('quit')
                        return
                    elif choice.lower() == 's':
                        break
                    elif choice.lower() == 'r':
                        undo_choice = input("\nGeben Sie die Koordinaten ein, die rückgängig gemacht oder markiert werden sollen (z.B. '1 1'): ")
                        try:
                            col, row = map(int, undo_choice.split())
                            if 1 <= row <= height and 1 <= col <= width:
                                parent_conns[current_player_index].send(f"undo {col - 1} {row - 1}")  # Koordinaten in 0-basierten Index umwandeln
                                updated_card = parent_conns[current_player_index].recv()
                                cards[current_player_index] = updated_card  # Aktualisierte Karte speichern
                            else:
                                print(f"\n{Fore.RED}Ungültige Koordinaten. Bitte geben Sie erneut ein.{Style.RESET_ALL}")
                        except ValueError:
                            print(f"\n{Fore.RED}Ungültige Eingabe.{Style.RESET_ALL}")
                    else:
                        try:
                            col, row = map(int, choice.split())  # Koordinaten eingeben
                            if 1 <= row <= height and 1 <= col <= width:
                                # Convert to 0-based index for internal use
                                row -= 1
                                col -= 1

                                parent_conns[current_player_index].send(f"toggle {col} {row}")  # Markierung umschalten

                                # Warten auf Antwort (aktualisierte Bingo-Karte nicht sofort drucken)
                                updated_card = parent_conns[current_player_index].recv()
                                cards[current_player_index] = updated_card  # Lokale Kartenliste aktualisieren
                                player_choices.append(updated_card)
                                break
                            else:
                                print(f"\n{Fore.RED}Ungültige Koordinaten. Bitte geben Sie erneut ein.{Style.RESET_ALL}")
                        except ValueError:
                            print(f"\n{Fore.RED}Ungültige Eingabe.{Style.RESET_ALL}")

            except ValueError:
                print(f"\n{Fore.RED}Ungültige Eingabe.{Style.RESET_ALL}")

         # After all players have made their move, print updated cards
        print(f"{Fore.YELLOW}\nAktualisierte Bingo-Karten:{Style.RESET_ALL}")
        for j in range(len(players)):
            print(f"\n{Fore.YELLOW}Spieler {player_names[j]} Bingokarte:{Style.RESET_ALL}")
            print_bingo_card(cards[j])

        # Check for win condition
        all_winners = []
        for j in range(len(players)):
            winners = check_win(cards[j])
            if winners:
                all_winners.append((player_names[j], winners))

        # Print all winners in this round
        for winner in all_winners:
            if winner[1]:
                if isinstance(winner[1], list):
                    win_conditions = ', '.join(map(str, winner[1]))  # Convert to strings before joining
                    print(f"{Fore.GREEN}Spieler {winner[0]} hat gewonnen!")
                else:
                    print(f"{Fore.GREEN}Spieler {winner[0]} hat gewonnen!")

        # If any player has won, save logs and return
        if all_winners:
            save_logs_to_file()
            print(f"{Fore.YELLOW}Log-Dateien wurden erfolgreich in 'Log-Datei.txt' gespeichert.{Style.RESET_ALL}")
            colorama.deinit()  # Reset terminal colors
            return

def main():
    if not os.path.exists(LOG_DIR):
        os.makedirs(LOG_DIR)

    welcome_screen()
    loading_animation()
    print("\nDas Spiel ist fertig geladen! Um das Spiel zu starten:")

    words_from_file = read_words_from_file(args.wordfile)
    if len(words_from_file) < args.xaxis * args.yaxis:
        print(f"{Fore.RED}Fehler: Nicht genug Wörter in der Datei.{Style.RESET_ALL}")
        sys.exit(1)

    num_players = int(input("Geben Sie die Anzahl der Spieler ein? "))

    if num_players < 2:
        print(f"{Fore.RED}Mindestens zwei Spieler werden benötigt.{Style.RESET_ALL}")
        sys.exit(1)

    parent_conns = []
    child_conns = []
    players = []

    for i in range(num_players):
        parent_conn, child_conn = Pipe()
        parent_conns.append(parent_conn)
        child_conns.append(child_conn)

        player_name = input(f"Geben Sie den Namen des Spielers {i + 1} ein: ")
        players.append((player_name, None))  # Don't ask for age

    processes = []
    cards = []

    for i in range(num_players):
        p = Process(target=player_process, args=(child_conns[i], i + 1, args.xaxis, args.yaxis, words_from_file))
        processes.append(p)
        p.start()

        parent_conns[i].send(players[i])
        card = parent_conns[i].recv()
        cards.append(card)

        # Print player's name and bingo card
        print(f"\n{Fore.YELLOW}Spieler {i + 1} ({players[i][0]}) Bingokarte:{Style.RESET_ALL}")
        print_bingo_card(card)

    play_game(parent_conns, processes, cards, players, args.xaxis, args.yaxis)  # Pass players as well

    for p in processes:
        p.join()

    save_logs_to_file()
    print(f"{Fore.YELLOW}Log-Dateien wurden erfolgreich in 'Log-Datei.txt' gespeichert.{Style.RESET_ALL}")
    colorama.deinit()  # Reset terminal colors


if __name__ == "__main__":
    main()
